export const traitKeyRegulators = {
  title: "Trait Key Regulators",
  text: `These are formatted on the structure chunk as arrays:<br>{chunkId: "xxx", number: ["singular"], formulaImportantTraitKeys: ["number"]}<br>1)<br>formulaImportantTraitKeys<br>Upgrade the importance of the trait value you set (eg "f" for "gender"). It will be more resistant to change by the sentence creation/translation process.<br>2)<br>educatorBlocksAnnotationsForTheseTraitKeys<br>Normally, in English Q sentence "The doctor is here." an annotation "male" or "female" would be added to "doctor", because Backend made a decision for one or the other, but that's opaque to the player because female or male it's still "doctor". And so with the annotation the player knows whether Polish A sentence should use "lekarz" or "lekarka". But some formulas the educator knows it's unambiguous - English Q sentence "The doctor and her dog." - educator has specified "f" for "gender" of "doctor" chunk, so they know there's no need for "female" annotation.<br>3)<br>merelyPreferredChoicesForQuestionSentence<br>Downgrade the importance of the traitValue you've set (eg "f" for "gender"). Think how in Polish there's no article but in English two. So Q: "Z kobietÄ…." should be A: ["With the woman.", "With a woman."] translating to both English forms, "definite" and "indefinite". This means we don't want to set a "form" trait value in the English formula. But English to Polish I only want Q sentences only with indefinite "With a woman." so I do set "form" to "indefinite" but downgrade its importance.`,
};
